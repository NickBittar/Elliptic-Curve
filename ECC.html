<html>
<head>
<style>
input.eqn {
	width: 20px;
}
</style>
</head>
<body>
<h2>Find Points on Elliptic Curve</h2>
<div id="equation">
	y^2 = x^3 + <input class="eqn" id="a">x + <input class="eqn" id="b"> in Z<input class="eqn" id="z">
</div>
<button onclick="ECC()">Do it</button>
</body>
<script>
	var Z,a,b,Na,Nb,G,Pa,Pb,Ka,Kb,M,C;
	var Xp, Yp, Xq, Yq, Xr, Yr;
	var S;	// slope

	// y^2 = X^3 + 5x + 4	in Z11
	//a = 5;
	//b = 4;
	//Z = 11;

	//ECC();
	
	function ECC()
	{
		
		a = parseInt(document.getElementById("a").value);
		b = parseInt(document.getElementById("b").value);
		Z = parseInt(document.getElementById("z").value);
		
		if(4*Math.pow(a, 3) + 27*Math.pow(b,2) == 0)
		{
			console.log("a and b are not valid!");
			return;
		}
		// Finding points on the curve
		var pts = generatePtsOnCurve();

		//Reorder pts for debugging
		pts = [ [0, 2], [0, 9], [2, 0], [4, 0], [5, 0], [10, 3], [10, 8] ];

		//Find two points by setting X values
		Xp = pts[0][0];
		//Yp = calcYECC(Xp);
		Yp = pts[0][1];

		Xq = pts[1][0];
		//Yq = calcYECC(Xq);
		Yq = pts[1][1];

		//console.log("X: " + Xp + ", " + Yp);
		//console.log("Y: " + Xq + ", " + Yq);
		
		//Find point R
		var R = add2DiffPts(Xp, Yp, Xq, Yq);
		Xr = R[0];
		Yr = -R[1];
		
		//console.log(Xr + " " + Yr);
		
		calcPtAdditionTable(pts);

		add2SamePts(0, 9);
		
	}
	function generatePtsOnCurve()
	{
		var possibleY = [];
		var possibleX = [];
		var pts = [];
		for(var i = 0; i < Z; i++)
		{
			possibleY[i] = (Math.pow(i, 2)%Z);
			//console.log("when Y=" + i + " ==> " + possibleY[i] );
		}
		
		for(var i = 0; i < Z; i++)
		{
			possibleX[i] = ((Math.pow(i, 3)+ a*i + b)%Z);
			//console.log("when X=" + i + " ==> " + possibleX[i] );
		}
		
		for(var y = 0; y < Z; y++)
		{
			for(var x = 0; x < Z; x++)
			{
				if(possibleY[y] == possibleX[x])
				{
					document.write("Point (" + x + ", " + y + ")<br>");
					pts[pts.length] = [x, y];
				}
			}
		}
		return pts;
	}
	function calcPtAdditionTable(pts)
	{
		var table = "";
		table += "<table>";
		table += "<tr>";
		table += "<td>X</td>";
		for(var i = 0; i < pts.length; i++)
		{
			table += "<td>(" + pts[i] + ")</td>";
		}
		table += "<td>Infinity</td>";
		table += "</tr>";
		for(var i = 0; i < pts.length; i++)
		{
			table += "<tr>";
			table += "<td>(" + pts[i] + ")</td>";
			for(var j = 0; j < pts.length; j++)
			{
				if(i === j)
				{
					table += "<td>(" + add2SamePts(pts[j][0], pts[j][1]) + ")</td>";
				}
				else
				{
					table += "<td>(" + add2DiffPts(pts[i][0], pts[i][1], pts[j][0], pts[j][1]) + ")</td>";
				}

			}
			table += "<td>(" + pts[i][0] + ", " + pts[i][1] + ")</td>"; 
			table += "</tr>";
		}
		table += "<tr><td>Infinity</td>";
		for(var j = 0; j < pts.length; j++)
		{
			table += "<td>(" + pts[j][0] + ", " + pts[j][1] + ")</td>";
		}
		table += "<td>Infinty</td>";
		table += "</tr>";
		table += "</table>";

		document.write(table);
	}
	function gcd(a, b)
	{
		if(a === b)
		{
			return a;
		}

		var r1 = Math.max(a, b), r2 = Math.min(a, b);
		var q = 0, r = 0;
		while(r2 > 0)
		{
			q = Math.floor(r1/r2);
			r = r1 - q*r2;
			r1 = r2;
			r2 = r;
		}
		return r1;
	}
	//Mods n by p and handles if n is negative
	function mod(n, p)
	{
		n %= p;
		if(n < 0)
		{
			n += p;
		}
		return n;
	}
	function findInverse(n)
	{
		// in respect to specified Z
		var q, r1, r2, r, t1, t2, t, i;
		// Init
		r1 = Z;
		r2 = n;
		t1 = 0;
		t2 = 1;
		while(r2 !== 0)
		{

			q = ~~(r1/r2);
			r = r1 - (q*r2);
			t = t1 - q*t2;

			//console.log(q + " " + r1 + " " + r2 + " " + r + " " + t1 + " " + t2 + " " + t );

			r1 = r2;
			r2 = r;
			t1 = t2;
			t2 = t;
		}

		i = t1;

		i = mod(i, Z);
		
		//console.log(i);

		return i;
		
	}
	function calcYECC(x)
	{
		var y;
		y = Math.sqrt(Math.pow(x, 3) + a*x + b);
		return y;
	}
	function CalcYLine(x)
	{
		// Equation of line going through Q,P,R
		var Y = S*x + S*Xp + Yp;
		return Y;
	}
	function add2SamePts(x, y)
	{
		var sDivisor = (2*y);
		var s = (3*Math.pow(x, 2) + a) / sDivisor;
		if(s !== ~~s)
		{
			if(gcd(Z, sDivisor) === 1)
			{
				sDivisor = findInverse(sDivisor);
				s = (3*Math.pow(x, 2) + a) * sDivisor;
			}
			else
			{
				return Infinity;
			}
		}
		//s *= Math.sign(y);
		s = mod(s, Z);

		var X = Math.pow(s, 2) - 2*x;
		var Y = s * (x - X) - y;
		return [mod(X, Z), mod(Y, Z)];
	}
	function add2DiffPts(x1, y1, x2, y2)
	{
		var sDivisor = (x1 - x2);
		var s = (y1 - y2) / sDivisor;
		if(s !== ~~s)
		{
			if(gcd(Z, mod(sDivisor, Z)) === 1)	// If the divisor has an inverse in Z
			{
				sDivisor = findInverse(sDivisor);
				s = (y1 - y2) * sDivisor;
			}
			else
			{
				return Infinity;
			}
		}
		//s *= Math.sign(x1- x2);
		s = mod(s, Z);
		var X = Math.pow(s, 2) - x2 - x1;
		X = mod(X, Z);
		var Y = s*(x1-X) - y1;
		Y = mod(Y, Z);
		return [X, Y];
	}
</script>
</html>